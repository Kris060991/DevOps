# Основы оркестрации контейнеров

Использование инструментов Docker Compose и Docker Swarm для совместного запуска контейнеров и их простейшей оркестрации.

Как тебе уже известно, **Docker** — это платформа для сборки, запуска и *доставки* приложений, призванная выполнять программное обеспечение практически вне зависимости от машины, на которой оно будет физически исполняться. Этот эффект достигается путем *контейнеризации* ПО, то есть помещения исполняемого ПО в отдельную подсреду — *контейнер*, содержащую в себе все необходимые зависимости и, если образ контейнера составлен хорошо, больше ничего лишнего. На самом деле, проблема зависимостей является намного более серьезной, чем может показаться с первого взгляда. Слабыми местами здесь являются не только недостающие файлы или библиотеки, а, возможно, версии библиотек или даже языка, значения переменных окружения и многие другие аспекты, которые могут, если и не сломать ПО окончательно, но значительно повлиять на его работоспособность. Контейнер гарантирует *одинаковое* выполнение контейнеризируемого ПО на любых машинах, так как содержит в себе все необходимое для последовательной работы находящегося внутри ПО. Этот аспект является особенно важным при разработке веб-сервисов, где возможны частые обновления ПО и переразмещение на разных машинах.

Обычно серьезное приложение состоит не из одной программы, то есть имеет не монолитную структуру, а микросервисную. Конечно, чисто формально каждый сервис может быть развернут в одном и том же контейнере, но данный подход не соответствует принципам SOLID и чистой архитектуры в целом. Например, при таком подходе практически невозможно или значительно усложняется процесс развертывания новой версии отдельного микросервиса. Обязательно следует запомнить основное правило контейнеризации: **«1 микросервис — 1 контейнер»**.

Теперь, когда правило насчет распределения микросервисов по контейнерам определено, стоит вспомнить еще об одном инструменте — **Docker Compose**, позволяющем запускать сразу несколько контейнеров вместе. **Docker Compose** не только дает запускать несколько Docker-контейнеров одновременно, но и предоставляет возможность определения их взаимодействия, что является необходимым условием для развертывания микросервисного приложения.

Однако один лишь **Docker Compose** позволяет запустить контейнеры только на одной машине. В реальности же микросервисные приложения распределены по различным машинам: реальным или виртуальным — значения не имеет. Обычно, конечно, это оказываются виртуальные машины, но далеко не обязательно, что все используемые одним программным обеспечением виртуальные машины находятся на одной и той же реальной. Зачастую это даже совсем не так. Здесь и появляется **Docker Swarm**. Вообще, словосочетание **Docker Swarm** означает как и просто группу машин, объединенных в один **кластер** с запущенными на них связанными между собой Docker-контейнерами, так и инструмент, который объединяет машины в такой кластер. **Кластер** — это объединение машин, или **узлов** (nodes), в единую сеть с распределенной по этим узлам нагрузкой в виде исполняемых в контейнерах приложениях. За запуск и курирование такого кластера отвечают специальные программы, называемые оркестраторами. **Docker Swarm** как раз является одной из них. **Docker Swarm** — это относительно простой и легкий в освоении оркестратор, обладающий всеми базовыми инструментами.

Наконец, откуда же взять машины, которые будут взяты за основу для узлов кластера? Ответ: виртуализация. Одним из наиболее популярных и простых инструментов создания виртуальных машин является **Vagrant**. **Vagrant** позволяет быстро, всего парой команд, создать несколько небольших виртуальных машин.

Итогом выполненной работы должен быть отчет с подробными описаниями выполнения каждого из пунктов, подкрепленного скриншотами. Отчет формируется в виде markdown-файла в директории `src` с именем `REPORT.MD`.

## Part 1. Запуск нескольких Docker-контейнеров с использованием Docker Compose

Стоит вспомнить, как работает Docker Compose! Давай сначала попробуем запустить микросервисное приложение из папки `src` таким образом, чтобы тесты постмана проходили успешно.

### Задание

1) Напиши Dockerfile для каждого отдельного микросервиса. Необходимые зависимости описаны в материалах. В отчете отобрази размер собранных образов любого сервиса различными способами.

2) Напиши Docker Compose файл, который осуществляет корректное взаимодействие сервисов. Пробрось порты для доступа к gateway service и session service из локальной машины. Помощь по Docker Compose ты найдешь в материалах.

3) Собери и разверни веб-сервис с помощью написанного Docker Compose файла на локальной машине.

4) Прогони заготовленные тесты через postman и удостоверься, что все они проходят успешно. Инструкцию по запуску тестов можно найти в материалах. В отчете отобрази результаты тестирования.

## Part 2. Создание виртуальных машин

Пришло время заготовить основу для будущих узлов кластера. Создадим виртуальную машину.

### Задание 

1) Установи и инициализируй Vagrant в корне проекта. Напиши Vagrantfile для одной виртуальной машины. Перенеси исходный код веб-сервиса в рабочую директорию виртуальной машины. Помощь по vagrant ты найдешь в материалах.

2) Зайди через консоль внутрь виртуальной машины и удостоверься, что исходный код встал, куда нужно. Останови и уничтожь виртуальную машину.

## Part 3. Создание простейшего Docker Swarm

Ну вот и пришло время создания твоего первого Docker Swarm!

### Задание

1) Модифицируй Vagrantfile для создания трех машин: manager01, worker01, worker02. Напиши shell-скрипты для установки Docker внутрь машин, инициализации и подключения к Docker Swarm. Помощь с Docker Swarm ты найдешь в материалах.

2) Загрузи собранные образы на Docker Hub и модифицируй Docker Compose файл для подгрузки расположенных на Docker Hub образов.

3) Подними виртуальные машины и перенеси на менеджер Docker Compose файл. Запусти стек сервисов, используя написанный Docker Compose файл.

4) Настрой прокси на базе nginx для доступа к gateway service и session service по оверлейной сети. Сами gateway service и session service сделай недоступными напрямую.

5) Прогони заготовленные тесты через Postman и удостоверься, что все они проходят успешно. В отчете отобрази результаты тестирования.

6) Используя команды Docker, отобрази в отчете распределение контейнеров по узлам.

7) Установи отдельным стеком Portainer внутри кластера. В отчете отобрази визуализацию распределения задач по узлам с помощью Portainer.
